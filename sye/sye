#!/usr/bin/env node

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	'use strict'

	const program = __webpack_require__(1);
	const cp = __webpack_require__(3)
	const os = __webpack_require__(7)
	const fs = __webpack_require__(5)
	const url = __webpack_require__(8)
	const debug = __webpack_require__(9)('sye')
	const prompt = __webpack_require__(15)()
	const net = __webpack_require__(14)

	const confdir = '/etc/sye'
	let registryUsername = process.env.SYE_REGISTRY_USERNAME
	let registryPassword = process.env.SYE_REGISTRY_PASSWORD
	const registryToken = process.env.SYE_REGISTRY_TOKEN

	function collectTags(tag, tags) {
	    tags.push(tag)
	    return tags
	}

	program
	    .version('0.0.1')
	    .usage('[command] <options>')

	program
	    .command('registry-start <ip>')
	    .description('Start a docker registry on this machine')
	    .option('-p, --prefix <name>', 'registry prefix name, default ott', 'ott')
	    .option('-f, --file <filename>', 'file with registry image, default ./registry.tar', './registry.tar')
	    .action( registryStart )

	program
	    .command('registry-add-release <registry-url>')
	    .description('Add a sye release to a docker registry')
	    .option('-f, --file <filename>', 'file with images, default ./images.tar', './images.tar')
	    .action( registryAddImages )

	program
	    .command('registry-add-images <registry-url>')
	    .description('Add stand-alone sye images to a docker registry')
	    .option('-f, --file <filename>', 'file with images, default ./images.tar.gz', './images.tar.gz')
	    .action( registryAddImages )

	program
	    .command('registry-remove')
	    .description('Remove the docker registry running on this machine')
	    .action( registryRemove )

	program
	    .command('cluster-create <registry-url> <etcd-ip...>')
	    .description('Create a configuration file for a cluster')
	    .option('-o, --output <filename>', 'configuration filename, default sye-environment.tar.gz',
	        './sye-environment.tar.gz')
	    .option('--release <release>', 'Use a specific release. Defaults to latest available in registry')
	    .option('-n, --no-check', 'Don\'t try to connect to registry.')
	    .option('--internal-ipv6', 'Use IPv6 for internal communication')
	    .action( clusterCreate )

	program
	    .command('cluster-join')
	    .description('Add this machine to a cluster')
	    .option('-f, --file <filename>', 'configuration filename',
	        './sye-environment.tar.gz')
	    .option('--mc-version <revision>', 'start a specific version of the machine-controller')
	    .option('--single <interface-name>', 'start single-pitcher services listening on an interface', '')
	    .option('--management <interface-name>', 'start management services listening on an interface', '')
	    .option('-p, --management-port <port>', 'start playout-management listening on a port', '81')
	    .option('-t, --management-tls-port <port>', 'start playout-management listening on a TLS port', '4433')
	    .option('--machine-name <machine-name>', 'name for this machine, defaults to hostname', false)
	    .option('--location <location>', 'location for this machine, default "Unknown"', 'Unknown')
	    .option('--machine-region <machine-region>', 'region for this machine, default "default"', 'default')
	    .option('--machine-zone <machine-zone>', 'zone for this machine, default "default"', 'default')
	    .option('--machine-tag <machine-tag>', 'optional tags for this machine, default "[]"', collectTags, [])
	    .action( clusterJoin )

	program
	    .command('cluster-leave')
	    .description('Remove machine-controller and all service containers from this node')
	    .option('--force', 'Disable warning')
	    .action( clusterLeave )

	program
	    .command('single-server <interface>')
	    .description('Start a single server installation')
	    .option('-p, --management-port <port>', 'start playout-management listening on a port', '81')
	    .option('-t, --management-tls-port <port>', 'start playout-management listening on a TLS port', '4433')
	    .description('Install a single-server setup on this machine')
	    .action( singleServer )

	program
	    .command('*')
	    .action( help )

	program
	  .parse(process.argv)

	if (!process.argv.slice(2).length) {
	    help()
	}

	function help() {
	    program.outputHelp()
	    console.log('Use <command> -h for help on a specific command.\n')
	    process.exit(1)
	}

	function registryStart(ip, options) {
	    let port = 5000
	    let name = 'registry'
	    let registryAddr = `${ip}:${port}`
	    let registryUrl = `http://${ip}:${port}/${options.prefix}`
	    let images = dockerLoad(options.file)
	    if(images.length !== 1) {
	        console.log(`Found ${images.length} images in ${options.file}, expected 1`)
	        process.exit(1)
	    }
	    let image = images[0]
	    console.log(`Using image ${image}`)

	    docker(`run -d --net=host \
	        --log-driver=json-file --log-opt max-size=20m --log-opt max-file=10 \
	        --restart unless-stopped \
	        -v registry-data:/var/lib/registry \
	        -e "REGISTRY_HTTP_ADDR=${registryAddr}" \
	        --name ${name} ${image}`)

	    let checkUrl = registryCheckUrlFromUrl(registryUrl)
	    let started = false
	    for( let n=0; n<12 && !started; n++) {
	        try {
	            execSync(`curl -s ${checkUrl}`)
	            started = true
	        }
	        catch (e) {
	            execSync('sleep 5')
	        }
	    }
	    if( !started ) {
	        console.log('Failed to start docker registry')
	        process.exit(1)
	    }
	    console.log(`Registry URL: ${registryUrl}`)
	}

	function registryAddImages(registryUrl, options) {

	    if (urlRequiresCredentials(registryUrl)) {
	        if (!(registryUsername && registryPassword)) {
	            promptRegistryCredentials()
	        }
	    }

	    let registryAddr = registryUrl.replace(/^(http|https):\/\//, '')
	    if (registryUsername && registryPassword) {
	        dockerLogin(registryUsername, registryPassword, registryAddr)
	    }

	    console.log('Loading images')
	    let images = dockerLoad(options.file)
	    for( let localName of images ) {
	        let [, service, revision] = localName.match(/^.+\/(.+):(.+)$/)
	        let remoteName = localName.replace(/^ott/, registryAddr)
	        docker(`tag ${localName} ${remoteName}`)
	        docker(`push ${remoteName}`)
	    }

	}

	function registryRemove() {
	    let id = docker('ps -a -q --no-trunc --filter name=^/registry$')
	    if(id) {
	        console.log('Stopping registry container')
	        docker('stop registry')

	        console.log('Removing container')
	        docker('rm -v registry')
	    }
	    else {
	        console.log('No registry to remove')
	    }
	}

	function clusterCreate( registryUrl, etcdIps, options ) {
	    let release = options.release || releaseVersionFromFile()
	    console.log(`Using release ${release}`)

	    if(urlRequiresCredentials(registryUrl)) {
	        if(!(registryUsername && registryPassword)) {
	            promptRegistryCredentials()
	        }
	    }

	    if (options.check) {
	        // Check that the registry URL is valid before creating the cluster config
	        try {
	            validateRegistryUrl(registryUrl, release)
	        } catch (e) {
	            console.log(`Failed to get ${registryUrl}. Check that the registry url is correct. ${e}`)
	            process.exit(1)
	        }
	    }
	    createConfigurationFile({
	        registryUrl,
	        registryUsername,
	        registryPassword,
	        registryToken,
	        etcdHosts: etcdIps.map(ip => net.isIPv6(ip) ? `https://[${ip}]:2379` : `https://${ip}:2379`),
	        release,
	        internalIPv6: options.internalIpv6 ? 'yes' : 'no',
	    }, options.output)
	}

	function clusterJoin( options ) {
	    verifyRoot('cluster-join')
	    configSystemForLogService()

	    if( options.single && options.management ) {
	        exit(1, 'Cannot be both single-server and management at the same time. Single-server includes management. Exiting.')
	    }

	    // extrac cluster configuration file to ${confdir}
	    extractConfigurationFile(confdir, options)

	    let global = JSON.parse(fs.readFileSync(confdir + '/global.json'))
	    let containerName = 'machine-controller-1'
	    let machineControllerVersion = options['mcVersion']
	        || imageReleaseRevision('machine-controller', global.release, global.registryUrl, global.registryUsername,
	            global.registryPassword, global.registryToken)

	    if (global.registryUsername && global.registryPassword) {
	        dockerLogin(global.registryUsername, global.registryPassword, global.registryUrl.replace(/^(http|https):\/\//, ''))
	    }

	    let registryPrefix = registryPrefixFromUrl(global.registryUrl)

		docker(`run -d \
			-e "SINGLE_SERVER_IF=${options.single}" \
	        -e "BOOTSTRAP_IF=${options.management}" \
	        -e "CONTAINER_NAME=${containerName}" \
	        -e "MEMORY_LIMIT=256" \
			-e "MACHINE_REGION=${options.machineRegion}" \
			-e "MACHINE_ZONE=${options.machineZone}" \
	        -e "MACHINE_TAGS=${options.machineTag}" \
	        -e "MANAGEMENT_PORT=${options.managementPort}" \
	        -e "MANAGEMENT_TLS_PORT=${options.managementTlsPort}" \
			-v /etc/sye:/etc/sye:rw \
			-v /var/lib/docker/volumes:/var/lib/docker/volumes:rw \
			-v /tmp/cores:/tmp/cores:rw \
			-v /var/run/docker.sock:/var/run/docker.sock \
			-v /etc/passwd:/etc/passwd:ro \
			-v /etc/group:/etc/group:ro \
			--net=host \
			--log-driver=json-file \
			--log-opt max-size=20m \
			--log-opt max-file=10 \
	        --memory 256M \
			--restart always \
			--name ${containerName} ${registryPrefix}/machine-controller:${machineControllerVersion}
	    `)
	    // start machine-controller
	}

	function clusterLeave( options ) {
	    verifyRoot('cluster-leave')

	    let services = [
	        'machine-controller-',
	        'pitcher_',
	        'frontend_',
	        'frontend-balancer_',
	        'playout-management_',
	        'playout-controller_',
	        'log_',
	        'login_',
	        'log-viewer_',
	        'influxdb_',
	        'metric-viewer_',
	        'cluster-monitor_',
	        'etcd_',
	        'video-source_',
	        'zookeeper_',
	        'kafka_',
	        'ad-impression-router_',
	        'ad-session-router_',
	        'ad-vast-requester_',
	        'ad-vast-reporter_',
	        'ad-deduplicator_',
	        'ad-playlist_',
	        'scaling_',
	        'schema-registry_',
	    ]

	    services.forEach( s => {stopAllInstances(s) })
	    services.forEach( s => {removeAllInstances(s) })
	    services.forEach( s => removeVolume(s) )

	    execSync('rm -rf /etc/sye')
	}

	function singleServer( networkInterface, options ) {
	    verifyRoot('single-server')
	    configSystemForLogService()

	    let ip
	    try {
	        ip = os.networkInterfaces()[networkInterface].filter( v => v.family === 'IPv4')[0].address
	    }
	    catch(e) {}

	    if(!ip) {
	        console.log('Failed to find ip address of interface ' + networkInterface)
	        process.exit(1)
	    }

	    console.log('\n> sye cluster-leave')
	    clusterLeave()

	    console.log('\n> sye registry-remove')
	    registryRemove()

	    console.log( '\n> sye registry-start 127.0.0.1')
	    registryStart('127.0.0.1', {prefix: 'ott', file: './registry.tar'})

	    console.log( '\n> sye registry-add-release http://127.0.0.1:5000/ott')
	    registryAddImages('http://127.0.0.1:5000/ott', {file: './images.tar'})

	    console.log( '\n> sye cluster-create http://127.0.0.1:5000/ott 127.0.0.1')
	    clusterCreate('http://127.0.0.1:5000/ott', ['127.0.0.1'], {output: './sye-environment.tar.gz'})

	    console.log( '\n> sye cluster-join')
	    clusterJoin({
	        single: networkInterface,
	        management: '',
	        file: './sye-environment.tar.gz',
	        location: 'Unknown',
	        managementPort: options.managementPort,
	        managementTlsPort: options.managementTlsPort
	    })

	    execSync(`rm sye-environment.tar.gz`)

	    console.log('System is starting. Will be available on http://' + ip + ':81')
	}

	function docker(command) {
	    try {
	        return execSync('docker ' +  command).toString()
	    }
	    catch (e) {
	        // Docker prints its error-messages to stderr
	        console.log('Docker command failed. Exiting.')
	        process.exit(1)
	    }
	}

	function dockerLoad(tarFile) {
	    let result = docker('load -q -i ' + tarFile)
	    let images = result.split('\n')
	        .filter(s => {
	            if (s.match(/no space left on device/)) {
	                console.log('Failed to load. No space left on device.')
	                process.exit(1)
	            } else {
	                return s.match(/^Loaded image: /)
	            }
	        })
	        .map( s => s.replace(/^Loaded image: /, ''))
	    return images
	}

	function dockerLogin(username, password, registry) {
	    console.log('Login external Docker registry')
	    if (registry.startsWith('docker.io')) {
	        docker(`login -u ${username} -p ${password}`)
	    } else {
	        docker(`login -u ${username} -p ${password} ${registry}`)
	    }
	}

	function getTokenFromDockerHub(username, password, repo, permissions) {
	    try {
	        let authRes = execSync(`curl -u ${username}:${password} "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${repo}:${permissions.join(',')}"`).toString()
	        return JSON.parse(authRes).token
	    }
	    catch (e) {
	        console.log('Docker authentication failed. Exiting.')
	        process.exit(1)
	    }
	}

	function registryCheckUrlFromUrl(registryUrl) {
	    let u = url.parse(registryUrl)
	    u.pathname = '/v2/'
	    return url.format(u)
	}

	function dockerRegistryApiUrlFromUrl(registryUrl) {
		let u = url.parse(registryUrl)
		u.pathname = '/v2' + u.pathname
		return url.format(u)
	}

	function quayRegistryApiUrlFromUrl(registryUrl) {
	    let u = url.parse(registryUrl)
	    u.pathname = '/api/v1/repository' + u.pathname
	    return url.format(u)
	}

	function registryPrefixFromUrl(registryUrl) {
		let u = url.parse(registryUrl)
	    return `${u.host}${u.pathname}`

	}

	function validateRegistryUrl(registryUrl, release) {
	    let p = url.parse(registryUrl)
	    if (p.host === 'quay.io' && registryToken) { // Request against quay.io
	        let url = quayRegistryApiUrlFromUrl(registryUrl) + '/release/tag/'
	        let res = execSync(`curl -s ${url} -H 'Authorization: Bearer ${registryToken}'`).toString()
	    } else if (p.host === 'docker.io') { // Request against Docker Hub
	        let url = dockerRegistryApiUrlFromUrl(registryUrl.replace('docker.io', 'registry.hub.docker.com')) + '/release/manifests/' + release
	        let token = getTokenFromDockerHub(registryUsername, registryPassword, `${p.path.replace('/', '')}/release`, ['pull'])
	        let res = JSON.parse(execSync(`curl -s -H "Accept: application/json" -H "Authorization: Bearer ${token}" "${url}"`).toString())
	        if (res.errors) {
	            throw JSON.stringify(res.errors, null, 2)
	        }
	    } else { // Request against Docker registry V2 endpoint
	        let url = dockerRegistryApiUrlFromUrl(registryUrl) + '/release/manifests/' + release
	        let cmd = registryUsername && registryPassword ? `curl -s -k -u${registryUsername}:${registryPassword} ${url}` :  `curl -s ${url}`
	        let res = execSync(cmd).toString()
	    }
	}

	function urlRequiresCredentials(registryUrl) {
	    return url.parse(registryUrl).host === 'docker.io'
	}

	function promptRegistryCredentials() {
	    registryUsername = prompt('SYE_REGISTRY_USERNAME: ')
	    registryPassword = prompt('SYE_REGISTRY_PASSWORD: ', {echo: ''})
	}

	function releaseVersionFromFile() {
	    try {
	      return fs.readFileSync('./release_version').toString().trim()
	    }
	    catch(e) {
	      throw 'Could not open release_version due to error: ' + e.stack
	    }
	}

	function imageReleaseRevision(image, releaseRevision, registryUrl, registryUsername, registryPassword, registryToken) {
	    // Return the revision of image that is included in a specific
	    // release.
	    let p = url.parse(registryUrl)
	    try {
	        if (registryToken) { // Request against quay.io
	            let baseUrl = quayRegistryApiUrlFromUrl(registryUrl) + '/release'
	            let res = execSync(`curl -s ${baseUrl}/tag/ -H 'Authorization: Bearer ${registryToken}'`).toString()
	            let tags = JSON.parse(res).tags
	            let manifestref = tags.find(t => t.name === releaseRevision).manifest_digest
	            res = execSync(`curl -s ${baseUrl}/manifest/${manifestref}/labels -H 'Authorization: Bearer ${registryToken}'`).toString()
	            let labels = JSON.parse(res).labels
	            return labels.find(label => label.key === 'systems.neti.servicerevision.' + image).value
	        } else {
	            let url
	            let cmd
	            if (p.host === 'docker.io') { // Request against Docker Hub
	                url = dockerRegistryApiUrlFromUrl(registryUrl.replace('docker.io', 'registry.hub.docker.com')) + '/release/manifests/' + releaseRevision
	                let token = getTokenFromDockerHub(registryUsername, registryPassword, `${p.path.replace('/', '')}/release`, ['pull'])
	                cmd = `curl -s -H "Accept: application/json" -H "Authorization: Bearer ${token}" "${url}"`
	            } else { // Request against Docker registry V2 endpoint
	                url = dockerRegistryApiUrlFromUrl(registryUrl) + '/release/manifests/' + releaseRevision
	                cmd = registryUsername && registryPassword ? `curl -s -k -u${registryUsername}:${registryPassword} ${url}` :  `curl -s ${url}`
	            }
	            let manifest = execSync(cmd).toString()
	            let labelInfo = JSON.parse(manifest).history[0].v1Compatibility
	            let labels = JSON.parse(labelInfo).container_config.Labels
	            return labels['systems.neti.servicerevision.' + image]
	        }
	    }
	    catch(err) {
	        console.error(`Failed to get revision for image ${image} in release ${releaseRevision} from registry at ${registryUrl}`) // eslint-disable-line
	        process.exit(1)
	    }
	}

	function createConfigurationFile(content, output) {
	    let dir = os.platform() === 'darwin' ? fs.mkdtempSync('/private/tmp/'): fs.mkdtempSync('/tmp/')
	    let tmpfile = dir + 'sye-environment.tar'
	    fs.writeFileSync( dir + '/global.json', JSON.stringify(content, undefined,4))
	    fs.mkdirSync(dir + '/keys')
	    execSync(`bash -c "openssl req -new -x509 -nodes -days 9999 -config <(cat) -keyout ${dir}/keys/ca.key -out ${dir}/keys/ca.pem 2>/dev/null"`, {input: opensslConf()})
	    execSync(`cp ${dir}/keys/ca.pem ${dir}/keys/root_ca.pem`)
	    execSync(`chmod -R go-rwx ${dir}/keys`)
	    execSync(`tar -C ${dir} -cf ${tmpfile} global.json`)
	    execSync(`tar -C ${dir} -rf ${tmpfile} keys`)
	    execSync(`cat ${tmpfile} | gzip > ${output}`)
	    execSync(`rm -rf ${dir}`)
	    console.log('Cluster configuration written to ' + output)
	}

	function extractConfigurationFile(confdir, options) {
	    try {
	        fs.statSync(confdir)
	        exit(1, `${confdir} already exists. Exiting.`)
	    }
	    catch(e) {}
	    fs.mkdirSync(confdir)
	    fs.mkdirSync(`${confdir}/instance-data`)
	    execSync(`tar -xzf ${options.file} -C ${confdir}`)
	    let machine = {
	        location: options.location,
	        machineName: options.machineName || execSync('hostname --fqdn').toString().replace('\n','')
	    }
	    fs.writeFileSync( confdir + '/machine.json', JSON.stringify(machine, undefined,4))
	}

	function verifyRoot(command) {
	    if (os.userInfo().uid !== 0) {
	    	exit(1, `${command} must be run as root`)
	    }
	}

	function configSystemForLogService() {
	    try {
	        // Replace the value of vm.max_map_count inline or add it to the end of the file is it doesn't exist
	        // reference here: https://superuser.com/questions/590630/sed-how-to-replace-line-if-found-or-append-to-end-of-file-if-not-found
	        execSync("sed '/^vm.max_map_count = /{h;s/=.*/= 262144/};${x;/^$/{s//vm.max_map_count = 262144/;H};x}' -i /etc/sysctl.conf") // eslint-disable-line
	        execSync('sysctl -p')
	    } catch (e) {
	        console.log(e)
	        exit(1, `Cannot set the OS parameter 'vm.max_map_count' to 262144. Exiting.`)
	    }
	}

	function execSync(cmd, options) {
	    debug(cmd)
	    return cp.execSync(cmd, options)
	}

	function exit(code, message) {
		console.log(message)
		process.exit(code)
	}

	function stopAllInstances(serviceName) {
	    execSync(`docker ps | grep ${serviceName} | awk '{FS=" "; print $1}' | xargs -r docker stop`)
	}

	function removeAllInstances(serviceName) {
	    execSync(`docker ps -a | grep ${serviceName} | awk '{FS=" "; print $1}' | xargs -r docker rm -v`)
	}

	function removeVolume(serviceName) {
	    execSync(`docker volume ls | grep ${serviceName} | awk '{FS=" "; print $2}' | xargs -r docker volume rm`)
	}

	function opensslConf() {
	    return `
	[ ca ]
	default_ca      = CA_default

	[ CA_default ]
	serial = ca-serial
	crl = ca-crl.pem
	database = ca-database.txt
	name_opt = CA_default
	cert_opt = CA_default
	default_crl_days = 9999
	default_md = md5

	[ req ]
	default_bits           = 2048
	days                   = 9999
	distinguished_name     = req_distinguished_name
	attributes             = req_attributes
	prompt                 = no

	[ req_distinguished_name ]
	C                      = SE
	ST                     = Stockholm
	L                      = Stockholm
	O                      = Net Insight
	OU                     = ott
	CN                     = ca
	emailAddress           = ca@neti.systems

	[ req_attributes ]
	challengePassword      = test
	`
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var EventEmitter = __webpack_require__(2).EventEmitter;
	var spawn = __webpack_require__(3).spawn;
	var readlink = __webpack_require__(4).readlinkSync;
	var path = __webpack_require__(6);
	var dirname = path.dirname;
	var basename = path.basename;
	var fs = __webpack_require__(5);

	/**
	 * Expose the root command.
	 */

	exports = module.exports = new Command();

	/**
	 * Expose `Command`.
	 */

	exports.Command = Command;

	/**
	 * Expose `Option`.
	 */

	exports.Option = Option;

	/**
	 * Initialize a new `Option` with the given `flags` and `description`.
	 *
	 * @param {String} flags
	 * @param {String} description
	 * @api public
	 */

	function Option(flags, description) {
	  this.flags = flags;
	  this.required = ~flags.indexOf('<');
	  this.optional = ~flags.indexOf('[');
	  this.bool = !~flags.indexOf('-no-');
	  flags = flags.split(/[ ,|]+/);
	  if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();
	  this.long = flags.shift();
	  this.description = description || '';
	}

	/**
	 * Return option name.
	 *
	 * @return {String}
	 * @api private
	 */

	Option.prototype.name = function() {
	  return this.long
	    .replace('--', '')
	    .replace('no-', '');
	};

	/**
	 * Check if `arg` matches the short or long flag.
	 *
	 * @param {String} arg
	 * @return {Boolean}
	 * @api private
	 */

	Option.prototype.is = function(arg) {
	  return arg == this.short || arg == this.long;
	};

	/**
	 * Initialize a new `Command`.
	 *
	 * @param {String} name
	 * @api public
	 */

	function Command(name) {
	  this.commands = [];
	  this.options = [];
	  this._execs = {};
	  this._allowUnknownOption = false;
	  this._args = [];
	  this._name = name || '';
	}

	/**
	 * Inherit from `EventEmitter.prototype`.
	 */

	Command.prototype.__proto__ = EventEmitter.prototype;

	/**
	 * Add command `name`.
	 *
	 * The `.action()` callback is invoked when the
	 * command `name` is specified via __ARGV__,
	 * and the remaining arguments are applied to the
	 * function for access.
	 *
	 * When the `name` is "*" an un-matched command
	 * will be passed as the first arg, followed by
	 * the rest of __ARGV__ remaining.
	 *
	 * Examples:
	 *
	 *      program
	 *        .version('0.0.1')
	 *        .option('-C, --chdir <path>', 'change the working directory')
	 *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')
	 *        .option('-T, --no-tests', 'ignore test hook')
	 *
	 *      program
	 *        .command('setup')
	 *        .description('run remote setup commands')
	 *        .action(function() {
	 *          console.log('setup');
	 *        });
	 *
	 *      program
	 *        .command('exec <cmd>')
	 *        .description('run the given remote command')
	 *        .action(function(cmd) {
	 *          console.log('exec "%s"', cmd);
	 *        });
	 *
	 *      program
	 *        .command('teardown <dir> [otherDirs...]')
	 *        .description('run teardown commands')
	 *        .action(function(dir, otherDirs) {
	 *          console.log('dir "%s"', dir);
	 *          if (otherDirs) {
	 *            otherDirs.forEach(function (oDir) {
	 *              console.log('dir "%s"', oDir);
	 *            });
	 *          }
	 *        });
	 *
	 *      program
	 *        .command('*')
	 *        .description('deploy the given env')
	 *        .action(function(env) {
	 *          console.log('deploying "%s"', env);
	 *        });
	 *
	 *      program.parse(process.argv);
	  *
	 * @param {String} name
	 * @param {String} [desc] for git-style sub-commands
	 * @return {Command} the new command
	 * @api public
	 */

	Command.prototype.command = function(name, desc, opts) {
	  opts = opts || {};
	  var args = name.split(/ +/);
	  var cmd = new Command(args.shift());

	  if (desc) {
	    cmd.description(desc);
	    this.executables = true;
	    this._execs[cmd._name] = true;
	    if (opts.isDefault) this.defaultExecutable = cmd._name;
	  }

	  cmd._noHelp = !!opts.noHelp;
	  this.commands.push(cmd);
	  cmd.parseExpectedArgs(args);
	  cmd.parent = this;

	  if (desc) return this;
	  return cmd;
	};

	/**
	 * Define argument syntax for the top-level command.
	 *
	 * @api public
	 */

	Command.prototype.arguments = function (desc) {
	  return this.parseExpectedArgs(desc.split(/ +/));
	};

	/**
	 * Add an implicit `help [cmd]` subcommand
	 * which invokes `--help` for the given command.
	 *
	 * @api private
	 */

	Command.prototype.addImplicitHelpCommand = function() {
	  this.command('help [cmd]', 'display help for [cmd]');
	};

	/**
	 * Parse expected `args`.
	 *
	 * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
	 *
	 * @param {Array} args
	 * @return {Command} for chaining
	 * @api public
	 */

	Command.prototype.parseExpectedArgs = function(args) {
	  if (!args.length) return;
	  var self = this;
	  args.forEach(function(arg) {
	    var argDetails = {
	      required: false,
	      name: '',
	      variadic: false
	    };

	    switch (arg[0]) {
	      case '<':
	        argDetails.required = true;
	        argDetails.name = arg.slice(1, -1);
	        break;
	      case '[':
	        argDetails.name = arg.slice(1, -1);
	        break;
	    }

	    if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {
	      argDetails.variadic = true;
	      argDetails.name = argDetails.name.slice(0, -3);
	    }
	    if (argDetails.name) {
	      self._args.push(argDetails);
	    }
	  });
	  return this;
	};

	/**
	 * Register callback `fn` for the command.
	 *
	 * Examples:
	 *
	 *      program
	 *        .command('help')
	 *        .description('display verbose help')
	 *        .action(function() {
	 *           // output help here
	 *        });
	 *
	 * @param {Function} fn
	 * @return {Command} for chaining
	 * @api public
	 */

	Command.prototype.action = function(fn) {
	  var self = this;
	  var listener = function(args, unknown) {
	    // Parse any so-far unknown options
	    args = args || [];
	    unknown = unknown || [];

	    var parsed = self.parseOptions(unknown);

	    // Output help if necessary
	    outputHelpIfNecessary(self, parsed.unknown);

	    // If there are still any unknown options, then we simply
	    // die, unless someone asked for help, in which case we give it
	    // to them, and then we die.
	    if (parsed.unknown.length > 0) {
	      self.unknownOption(parsed.unknown[0]);
	    }

	    // Leftover arguments need to be pushed back. Fixes issue #56
	    if (parsed.args.length) args = parsed.args.concat(args);

	    self._args.forEach(function(arg, i) {
	      if (arg.required && null == args[i]) {
	        self.missingArgument(arg.name);
	      } else if (arg.variadic) {
	        if (i !== self._args.length - 1) {
	          self.variadicArgNotLast(arg.name);
	        }

	        args[i] = args.splice(i);
	      }
	    });

	    // Always append ourselves to the end of the arguments,
	    // to make sure we match the number of arguments the user
	    // expects
	    if (self._args.length) {
	      args[self._args.length] = self;
	    } else {
	      args.push(self);
	    }

	    fn.apply(self, args);
	  };
	  var parent = this.parent || this;
	  var name = parent === this ? '*' : this._name;
	  parent.on(name, listener);
	  if (this._alias) parent.on(this._alias, listener);
	  return this;
	};

	/**
	 * Define option with `flags`, `description` and optional
	 * coercion `fn`.
	 *
	 * The `flags` string should contain both the short and long flags,
	 * separated by comma, a pipe or space. The following are all valid
	 * all will output this way when `--help` is used.
	 *
	 *    "-p, --pepper"
	 *    "-p|--pepper"
	 *    "-p --pepper"
	 *
	 * Examples:
	 *
	 *     // simple boolean defaulting to false
	 *     program.option('-p, --pepper', 'add pepper');
	 *
	 *     --pepper
	 *     program.pepper
	 *     // => Boolean
	 *
	 *     // simple boolean defaulting to true
	 *     program.option('-C, --no-cheese', 'remove cheese');
	 *
	 *     program.cheese
	 *     // => true
	 *
	 *     --no-cheese
	 *     program.cheese
	 *     // => false
	 *
	 *     // required argument
	 *     program.option('-C, --chdir <path>', 'change the working directory');
	 *
	 *     --chdir /tmp
	 *     program.chdir
	 *     // => "/tmp"
	 *
	 *     // optional argument
	 *     program.option('-c, --cheese [type]', 'add cheese [marble]');
	 *
	 * @param {String} flags
	 * @param {String} description
	 * @param {Function|Mixed} fn or default
	 * @param {Mixed} defaultValue
	 * @return {Command} for chaining
	 * @api public
	 */

	Command.prototype.option = function(flags, description, fn, defaultValue) {
	  var self = this
	    , option = new Option(flags, description)
	    , oname = option.name()
	    , name = camelcase(oname);

	  // default as 3rd arg
	  if (typeof fn != 'function') {
	    if (fn instanceof RegExp) {
	      var regex = fn;
	      fn = function(val, def) {
	        var m = regex.exec(val);
	        return m ? m[0] : def;
	      }
	    }
	    else {
	      defaultValue = fn;
	      fn = null;
	    }
	  }

	  // preassign default value only for --no-*, [optional], or <required>
	  if (false == option.bool || option.optional || option.required) {
	    // when --no-* we make sure default is true
	    if (false == option.bool) defaultValue = true;
	    // preassign only if we have a default
	    if (undefined !== defaultValue) self[name] = defaultValue;
	  }

	  // register the option
	  this.options.push(option);

	  // when it's passed assign the value
	  // and conditionally invoke the callback
	  this.on(oname, function(val) {
	    // coercion
	    if (null !== val && fn) val = fn(val, undefined === self[name]
	      ? defaultValue
	      : self[name]);

	    // unassigned or bool
	    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
	      // if no value, bool true, and we have a default, then use it!
	      if (null == val) {
	        self[name] = option.bool
	          ? defaultValue || true
	          : false;
	      } else {
	        self[name] = val;
	      }
	    } else if (null !== val) {
	      // reassign
	      self[name] = val;
	    }
	  });

	  return this;
	};

	/**
	 * Allow unknown options on the command line.
	 *
	 * @param {Boolean} arg if `true` or omitted, no error will be thrown
	 * for unknown options.
	 * @api public
	 */
	Command.prototype.allowUnknownOption = function(arg) {
	    this._allowUnknownOption = arguments.length === 0 || arg;
	    return this;
	};

	/**
	 * Parse `argv`, settings options and invoking commands when defined.
	 *
	 * @param {Array} argv
	 * @return {Command} for chaining
	 * @api public
	 */

	Command.prototype.parse = function(argv) {
	  // implicit help
	  if (this.executables) this.addImplicitHelpCommand();

	  // store raw args
	  this.rawArgs = argv;

	  // guess name
	  this._name = this._name || basename(argv[1], '.js');

	  // github-style sub-commands with no sub-command
	  if (this.executables && argv.length < 3 && !this.defaultExecutable) {
	    // this user needs help
	    argv.push('--help');
	  }

	  // process argv
	  var parsed = this.parseOptions(this.normalize(argv.slice(2)));
	  var args = this.args = parsed.args;

	  var result = this.parseArgs(this.args, parsed.unknown);

	  // executable sub-commands
	  var name = result.args[0];
	  if (this._execs[name] && typeof this._execs[name] != "function") {
	    return this.executeSubCommand(argv, args, parsed.unknown);
	  } else if (this.defaultExecutable) {
	    // use the default subcommand
	    args.unshift(name = this.defaultExecutable);
	    return this.executeSubCommand(argv, args, parsed.unknown);
	  }

	  return result;
	};

	/**
	 * Execute a sub-command executable.
	 *
	 * @param {Array} argv
	 * @param {Array} args
	 * @param {Array} unknown
	 * @api private
	 */

	Command.prototype.executeSubCommand = function(argv, args, unknown) {
	  args = args.concat(unknown);

	  if (!args.length) this.help();
	  if ('help' == args[0] && 1 == args.length) this.help();

	  // <cmd> --help
	  if ('help' == args[0]) {
	    args[0] = args[1];
	    args[1] = '--help';
	  }

	  // executable
	  var f = argv[1];
	  // name of the subcommand, link `pm-install`
	  var bin = basename(f, '.js') + '-' + args[0];


	  // In case of globally installed, get the base dir where executable
	  //  subcommand file should be located at
	  var baseDir
	    , link = readlink(f);

	  // when symbolink is relative path
	  if (link !== f && link.charAt(0) !== '/') {
	    link = path.join(dirname(f), link)
	  }
	  baseDir = dirname(link);

	  // prefer local `./<bin>` to bin in the $PATH
	  var localBin = path.join(baseDir, bin);

	  // whether bin file is a js script with explicit `.js` extension
	  var isExplicitJS = false;
	  if (exists(localBin + '.js')) {
	    bin = localBin + '.js';
	    isExplicitJS = true;
	  } else if (exists(localBin)) {
	    bin = localBin;
	  }

	  args = args.slice(1);

	  var proc;
	  if (process.platform !== 'win32') {
	    if (isExplicitJS) {
	      args.unshift(localBin);
	      // add executable arguments to spawn
	      args = (process.execArgv || []).concat(args);

	      proc = spawn('node', args, { stdio: 'inherit', customFds: [0, 1, 2] });
	    } else {
	      proc = spawn(bin, args, { stdio: 'inherit', customFds: [0, 1, 2] });
	    }
	  } else {
	    args.unshift(localBin);
	    proc = spawn(process.execPath, args, { stdio: 'inherit'});
	  }

	  proc.on('close', process.exit.bind(process));
	  proc.on('error', function(err) {
	    if (err.code == "ENOENT") {
	      console.error('\n  %s(1) does not exist, try --help\n', bin);
	    } else if (err.code == "EACCES") {
	      console.error('\n  %s(1) not executable. try chmod or run with root\n', bin);
	    }
	    process.exit(1);
	  });

	  // Store the reference to the child process
	  this.runningCommand = proc;
	};

	/**
	 * Normalize `args`, splitting joined short flags. For example
	 * the arg "-abc" is equivalent to "-a -b -c".
	 * This also normalizes equal sign and splits "--abc=def" into "--abc def".
	 *
	 * @param {Array} args
	 * @return {Array}
	 * @api private
	 */

	Command.prototype.normalize = function(args) {
	  var ret = []
	    , arg
	    , lastOpt
	    , index;

	  for (var i = 0, len = args.length; i < len; ++i) {
	    arg = args[i];
	    if (i > 0) {
	      lastOpt = this.optionFor(args[i-1]);
	    }

	    if (arg === '--') {
	      // Honor option terminator
	      ret = ret.concat(args.slice(i));
	      break;
	    } else if (lastOpt && lastOpt.required) {
	      ret.push(arg);
	    } else if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]) {
	      arg.slice(1).split('').forEach(function(c) {
	        ret.push('-' + c);
	      });
	    } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {
	      ret.push(arg.slice(0, index), arg.slice(index + 1));
	    } else {
	      ret.push(arg);
	    }
	  }

	  return ret;
	};

	/**
	 * Parse command `args`.
	 *
	 * When listener(s) are available those
	 * callbacks are invoked, otherwise the "*"
	 * event is emitted and those actions are invoked.
	 *
	 * @param {Array} args
	 * @return {Command} for chaining
	 * @api private
	 */

	Command.prototype.parseArgs = function(args, unknown) {
	  var name;

	  if (args.length) {
	    name = args[0];
	    if (this.listeners(name).length) {
	      this.emit(args.shift(), args, unknown);
	    } else {
	      this.emit('*', args);
	    }
	  } else {
	    outputHelpIfNecessary(this, unknown);

	    // If there were no args and we have unknown options,
	    // then they are extraneous and we need to error.
	    if (unknown.length > 0) {
	      this.unknownOption(unknown[0]);
	    }
	  }

	  return this;
	};

	/**
	 * Return an option matching `arg` if any.
	 *
	 * @param {String} arg
	 * @return {Option}
	 * @api private
	 */

	Command.prototype.optionFor = function(arg) {
	  for (var i = 0, len = this.options.length; i < len; ++i) {
	    if (this.options[i].is(arg)) {
	      return this.options[i];
	    }
	  }
	};

	/**
	 * Parse options from `argv` returning `argv`
	 * void of these options.
	 *
	 * @param {Array} argv
	 * @return {Array}
	 * @api public
	 */

	Command.prototype.parseOptions = function(argv) {
	  var args = []
	    , len = argv.length
	    , literal
	    , option
	    , arg;

	  var unknownOptions = [];

	  // parse options
	  for (var i = 0; i < len; ++i) {
	    arg = argv[i];

	    // literal args after --
	    if ('--' == arg) {
	      literal = true;
	      continue;
	    }

	    if (literal) {
	      args.push(arg);
	      continue;
	    }

	    // find matching Option
	    option = this.optionFor(arg);

	    // option is defined
	    if (option) {
	      // requires arg
	      if (option.required) {
	        arg = argv[++i];
	        if (null == arg) return this.optionMissingArgument(option);
	        this.emit(option.name(), arg);
	      // optional arg
	      } else if (option.optional) {
	        arg = argv[i+1];
	        if (null == arg || ('-' == arg[0] && '-' != arg)) {
	          arg = null;
	        } else {
	          ++i;
	        }
	        this.emit(option.name(), arg);
	      // bool
	      } else {
	        this.emit(option.name());
	      }
	      continue;
	    }

	    // looks like an option
	    if (arg.length > 1 && '-' == arg[0]) {
	      unknownOptions.push(arg);

	      // If the next argument looks like it might be
	      // an argument for this option, we pass it on.
	      // If it isn't, then it'll simply be ignored
	      if (argv[i+1] && '-' != argv[i+1][0]) {
	        unknownOptions.push(argv[++i]);
	      }
	      continue;
	    }

	    // arg
	    args.push(arg);
	  }

	  return { args: args, unknown: unknownOptions };
	};

	/**
	 * Return an object containing options as key-value pairs
	 *
	 * @return {Object}
	 * @api public
	 */
	Command.prototype.opts = function() {
	  var result = {}
	    , len = this.options.length;

	  for (var i = 0 ; i < len; i++) {
	    var key = camelcase(this.options[i].name());
	    result[key] = key === 'version' ? this._version : this[key];
	  }
	  return result;
	};

	/**
	 * Argument `name` is missing.
	 *
	 * @param {String} name
	 * @api private
	 */

	Command.prototype.missingArgument = function(name) {
	  console.error();
	  console.error("  error: missing required argument `%s'", name);
	  console.error();
	  process.exit(1);
	};

	/**
	 * `Option` is missing an argument, but received `flag` or nothing.
	 *
	 * @param {String} option
	 * @param {String} flag
	 * @api private
	 */

	Command.prototype.optionMissingArgument = function(option, flag) {
	  console.error();
	  if (flag) {
	    console.error("  error: option `%s' argument missing, got `%s'", option.flags, flag);
	  } else {
	    console.error("  error: option `%s' argument missing", option.flags);
	  }
	  console.error();
	  process.exit(1);
	};

	/**
	 * Unknown option `flag`.
	 *
	 * @param {String} flag
	 * @api private
	 */

	Command.prototype.unknownOption = function(flag) {
	  if (this._allowUnknownOption) return;
	  console.error();
	  console.error("  error: unknown option `%s'", flag);
	  console.error();
	  process.exit(1);
	};

	/**
	 * Variadic argument with `name` is not the last argument as required.
	 *
	 * @param {String} name
	 * @api private
	 */

	Command.prototype.variadicArgNotLast = function(name) {
	  console.error();
	  console.error("  error: variadic arguments must be last `%s'", name);
	  console.error();
	  process.exit(1);
	};

	/**
	 * Set the program version to `str`.
	 *
	 * This method auto-registers the "-V, --version" flag
	 * which will print the version number when passed.
	 *
	 * @param {String} str
	 * @param {String} flags
	 * @return {Command} for chaining
	 * @api public
	 */

	Command.prototype.version = function(str, flags) {
	  if (0 == arguments.length) return this._version;
	  this._version = str;
	  flags = flags || '-V, --version';
	  this.option(flags, 'output the version number');
	  this.on('version', function() {
	    process.stdout.write(str + '\n');
	    process.exit(0);
	  });
	  return this;
	};

	/**
	 * Set the description to `str`.
	 *
	 * @param {String} str
	 * @return {String|Command}
	 * @api public
	 */

	Command.prototype.description = function(str) {
	  if (0 === arguments.length) return this._description;
	  this._description = str;
	  return this;
	};

	/**
	 * Set an alias for the command
	 *
	 * @param {String} alias
	 * @return {String|Command}
	 * @api public
	 */

	Command.prototype.alias = function(alias) {
	  if (0 == arguments.length) return this._alias;
	  this._alias = alias;
	  return this;
	};

	/**
	 * Set / get the command usage `str`.
	 *
	 * @param {String} str
	 * @return {String|Command}
	 * @api public
	 */

	Command.prototype.usage = function(str) {
	  var args = this._args.map(function(arg) {
	    return humanReadableArgName(arg);
	  });

	  var usage = '[options]'
	    + (this.commands.length ? ' [command]' : '')
	    + (this._args.length ? ' ' + args.join(' ') : '');

	  if (0 == arguments.length) return this._usage || usage;
	  this._usage = str;

	  return this;
	};

	/**
	 * Get the name of the command
	 *
	 * @param {String} name
	 * @return {String|Command}
	 * @api public
	 */

	Command.prototype.name = function() {
	  return this._name;
	};

	/**
	 * Return the largest option length.
	 *
	 * @return {Number}
	 * @api private
	 */

	Command.prototype.largestOptionLength = function() {
	  return this.options.reduce(function(max, option) {
	    return Math.max(max, option.flags.length);
	  }, 0);
	};

	/**
	 * Return help for options.
	 *
	 * @return {String}
	 * @api private
	 */

	Command.prototype.optionHelp = function() {
	  var width = this.largestOptionLength();

	  // Prepend the help information
	  return [pad('-h, --help', width) + '  ' + 'output usage information']
	      .concat(this.options.map(function(option) {
	        return pad(option.flags, width) + '  ' + option.description;
	      }))
	      .join('\n');
	};

	/**
	 * Return command help documentation.
	 *
	 * @return {String}
	 * @api private
	 */

	Command.prototype.commandHelp = function() {
	  if (!this.commands.length) return '';

	  var commands = this.commands.filter(function(cmd) {
	    return !cmd._noHelp;
	  }).map(function(cmd) {
	    var args = cmd._args.map(function(arg) {
	      return humanReadableArgName(arg);
	    }).join(' ');

	    return [
	      cmd._name
	        + (cmd._alias ? '|' + cmd._alias : '')
	        + (cmd.options.length ? ' [options]' : '')
	        + ' ' + args
	      , cmd.description()
	    ];
	  });

	  var width = commands.reduce(function(max, command) {
	    return Math.max(max, command[0].length);
	  }, 0);

	  return [
	    ''
	    , '  Commands:'
	    , ''
	    , commands.map(function(cmd) {
	      var desc = cmd[1] ? '  ' + cmd[1] : '';
	      return pad(cmd[0], width) + desc;
	    }).join('\n').replace(/^/gm, '    ')
	    , ''
	  ].join('\n');
	};

	/**
	 * Return program help documentation.
	 *
	 * @return {String}
	 * @api private
	 */

	Command.prototype.helpInformation = function() {
	  var desc = [];
	  if (this._description) {
	    desc = [
	      '  ' + this._description
	      , ''
	    ];
	  }

	  var cmdName = this._name;
	  if (this._alias) {
	    cmdName = cmdName + '|' + this._alias;
	  }
	  var usage = [
	    ''
	    ,'  Usage: ' + cmdName + ' ' + this.usage()
	    , ''
	  ];

	  var cmds = [];
	  var commandHelp = this.commandHelp();
	  if (commandHelp) cmds = [commandHelp];

	  var options = [
	    '  Options:'
	    , ''
	    , '' + this.optionHelp().replace(/^/gm, '    ')
	    , ''
	    , ''
	  ];

	  return usage
	    .concat(cmds)
	    .concat(desc)
	    .concat(options)
	    .join('\n');
	};

	/**
	 * Output help information for this command
	 *
	 * @api public
	 */

	Command.prototype.outputHelp = function(cb) {
	  if (!cb) {
	    cb = function(passthru) {
	      return passthru;
	    }
	  }
	  process.stdout.write(cb(this.helpInformation()));
	  this.emit('--help');
	};

	/**
	 * Output help information and exit.
	 *
	 * @api public
	 */

	Command.prototype.help = function(cb) {
	  this.outputHelp(cb);
	  process.exit();
	};

	/**
	 * Camel-case the given `flag`
	 *
	 * @param {String} flag
	 * @return {String}
	 * @api private
	 */

	function camelcase(flag) {
	  return flag.split('-').reduce(function(str, word) {
	    return str + word[0].toUpperCase() + word.slice(1);
	  });
	}

	/**
	 * Pad `str` to `width`.
	 *
	 * @param {String} str
	 * @param {Number} width
	 * @return {String}
	 * @api private
	 */

	function pad(str, width) {
	  var len = Math.max(0, width - str.length);
	  return str + Array(len + 1).join(' ');
	}

	/**
	 * Output help information if necessary
	 *
	 * @param {Command} command to output help for
	 * @param {Array} array of options to search for -h or --help
	 * @api private
	 */

	function outputHelpIfNecessary(cmd, options) {
	  options = options || [];
	  for (var i = 0; i < options.length; i++) {
	    if (options[i] == '--help' || options[i] == '-h') {
	      cmd.outputHelp();
	      process.exit(0);
	    }
	  }
	}

	/**
	 * Takes an argument an returns its human readable equivalent for help usage.
	 *
	 * @param {Object} arg
	 * @return {String}
	 * @api private
	 */

	function humanReadableArgName(arg) {
	  var nameOutput = arg.name + (arg.variadic === true ? '...' : '');

	  return arg.required
	    ? '<' + nameOutput + '>'
	    : '[' + nameOutput + ']'
	}

	// for versions before node v0.8 when there weren't `fs.existsSync`
	function exists(file) {
	  try {
	    if (fs.statSync(file).isFile()) {
	      return true;
	    }
	  } catch (e) {
	    return false;
	  }
	}



/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = require("events");

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("child_process");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(5)
	  , lstat = fs.lstatSync;

	exports.readlinkSync = function (p) {
	  if (lstat(p).isSymbolicLink()) {
	    return fs.readlinkSync(p);
	  } else {
	    return p;
	  }
	};




/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = require("os");

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = require("url");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */

	var tty = __webpack_require__(10);
	var util = __webpack_require__(11);

	/**
	 * This is the Node.js implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(12);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;

	/**
	 * Colors.
	 */

	exports.colors = [6, 2, 3, 4, 5, 1];

	/**
	 * The file descriptor to write the `debug()` calls to.
	 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
	 *
	 *   $ DEBUG_FD=3 node script.js 3>debug.log
	 */

	var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
	var stream = 1 === fd ? process.stdout :
	             2 === fd ? process.stderr :
	             createWritableStdioStream(fd);

	/**
	 * Is stdout a TTY? Colored output is enabled when `true`.
	 */

	function useColors() {
	  var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();
	  if (0 === debugColors.length) {
	    return tty.isatty(fd);
	  } else {
	    return '0' !== debugColors
	        && 'no' !== debugColors
	        && 'false' !== debugColors
	        && 'disabled' !== debugColors;
	  }
	}

	/**
	 * Map %o to `util.inspect()`, since Node doesn't do that out of the box.
	 */

	var inspect = (4 === util.inspect.length ?
	  // node <= 0.8.x
	  function (v, colors) {
	    return util.inspect(v, void 0, void 0, colors);
	  } :
	  // node > 0.8.x
	  function (v, colors) {
	    return util.inspect(v, { colors: colors });
	  }
	);

	exports.formatters.o = function(v) {
	  return inspect(v, this.useColors)
	    .replace(/\s*\n\s*/g, ' ');
	};

	/**
	 * Adds ANSI color escape codes if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	  var name = this.namespace;

	  if (useColors) {
	    var c = this.color;

	    args[0] = '  \u001b[3' + c + ';1m' + name + ' '
	      + '\u001b[0m'
	      + args[0] + '\u001b[3' + c + 'm'
	      + ' +' + exports.humanize(this.diff) + '\u001b[0m';
	  } else {
	    args[0] = new Date().toUTCString()
	      + ' ' + name + ' ' + args[0];
	  }
	  return args;
	}

	/**
	 * Invokes `console.error()` with the specified arguments.
	 */

	function log() {
	  return stream.write(util.format.apply(this, arguments) + '\n');
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  if (null == namespaces) {
	    // If you set a process.env field to null or undefined, it gets cast to the
	    // string 'null' or 'undefined'. Just delete instead.
	    delete process.env.DEBUG;
	  } else {
	    process.env.DEBUG = namespaces;
	  }
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  return process.env.DEBUG;
	}

	/**
	 * Copied from `node/src/node.js`.
	 *
	 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
	 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
	 */

	function createWritableStdioStream (fd) {
	  var stream;
	  var tty_wrap = process.binding('tty_wrap');

	  // Note stream._type is used for test-module-load-list.js

	  switch (tty_wrap.guessHandleType(fd)) {
	    case 'TTY':
	      stream = new tty.WriteStream(fd);
	      stream._type = 'tty';

	      // Hack to have stream not keep the event loop alive.
	      // See https://github.com/joyent/node/issues/1726
	      if (stream._handle && stream._handle.unref) {
	        stream._handle.unref();
	      }
	      break;

	    case 'FILE':
	      var fs = __webpack_require__(5);
	      stream = new fs.SyncWriteStream(fd, { autoClose: false });
	      stream._type = 'fs';
	      break;

	    case 'PIPE':
	    case 'TCP':
	      var net = __webpack_require__(14);
	      stream = new net.Socket({
	        fd: fd,
	        readable: false,
	        writable: true
	      });

	      // FIXME Should probably have an option in net.Socket to create a
	      // stream from an existing fd which is writable only. But for now
	      // we'll just add this hack and set the `readable` member to false.
	      // Test: ./node test/fixtures/echo.js < /etc/passwd
	      stream.readable = false;
	      stream.read = null;
	      stream._type = 'pipe';

	      // FIXME Hack to have stream not keep the event loop alive.
	      // See https://github.com/joyent/node/issues/1726
	      if (stream._handle && stream._handle.unref) {
	        stream._handle.unref();
	      }
	      break;

	    default:
	      // Probably an error on in uv_guess_handle()
	      throw new Error('Implement me. Unknown stream file type!');
	  }

	  // For supporting legacy API we put the FD here.
	  stream.fd = fd;

	  stream._isStdio = true;

	  return stream;
	}

	/**
	 * Enable namespaces listed in `process.env.DEBUG` initially.
	 */

	exports.enable(load());


/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = require("tty");

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(13);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 13 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = require("net");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var fs = __webpack_require__(5);
	var term = 13; // carriage return

	/**
	 * create -- sync function for reading user input from stdin
	 * @param   {Object} config {
	 *   sigint: {Boolean} exit on ^C
	 *   autocomplete: {StringArray} function({String})
	 *   history: {String} a history control object (see `prompt-sync-history`)
	 * }
	 * @returns {Function} prompt function 
	 */

	function create(config) {

	  config = config || {};
	  var sigint = config.sigint;
	  var autocomplete = config.autocomplete = 
	    config.autocomplete || function(){return []};
	  var history = config.history;
	  prompt.history = history || {save: function(){}};
	  prompt.hide = function (ask) { return prompt(ask, {echo: ''}) };

	  return prompt;


	  /**
	   * prompt -- sync function for reading user input from stdin
	   *  @param {String} ask opening question/statement to prompt for
	   *  @param {String} value initial value for the prompt
	   *  @param   {Object} opts {
	   *   echo: set to a character to be echoed, default is '*'. Use '' for no echo
	   *   value: {String} initial value for the prompt
	   *   ask: {String} opening question/statement to prompt for, does not override ask param
	   *   autocomplete: {StringArray} function({String})
	   * }
	   * 
	   * @returns {string} Returns the string input or (if sigint === false) 
	   *                   null if user terminates with a ^C  
	   */


	  function prompt(ask, value, opts) {
	    var insert = 0, savedinsert = 0, res, i, savedstr;
	    opts = opts || {};

	    if (Object(ask) === ask) {
	      opts = ask;
	      ask = opts.ask;
	    } else if (Object(value) === value) {
	      opts = value;
	      value = opts.value;
	    }
	    ask = ask || '';
	    var echo = opts.echo;
	    var masked = 'echo' in opts;
	    autocomplete = opts.autocomplete || autocomplete;

	    var fd = (process.platform === 'win32') ? 
	      process.stdin.fd :
	      fs.openSync('/dev/tty', 'rs');

	    var wasRaw = process.stdin.isRaw;
	    if (!wasRaw) { process.stdin.setRawMode(true); }

	    var buf = new Buffer(3);
	    var str = '', character, read;

	    savedstr = '';

	    if (ask) {
	      process.stdout.write(ask);
	    }

	    var cycle = 0;
	    var prevComplete;

	    while (true) {
	      read = fs.readSync(fd, buf, 0, 3);
	      if (read > 1) { // received a control sequence
	        switch(buf.toString()) {
	          case '\u001b[A':  //up arrow
	            if (masked) break;
	            if (!history) break;
	            if (history.atStart()) break;

	            if (history.atEnd()) {
	              savedstr = str;
	              savedinsert = insert;
	            }
	            str = history.prev();
	            insert = str.length;
	            process.stdout.write('\u001b[2K\u001b[0G' + ask + str);
	            break;
	          case '\u001b[B':  //down arrow
	            if (masked) break;
	            if (!history) break;
	            if (history.pastEnd()) break;
	            
	            if (history.atPenultimate()) {
	              str = savedstr;
	              insert = savedinsert;
	              history.next();
	            } else {
	              str = history.next();
	              insert = str.length;
	            }
	            process.stdout.write('\u001b[2K\u001b[0G'+ ask + str + '\u001b['+(insert+ask.length+1)+'G');
	            break;
	          case '\u001b[D': //left arrow
	            if (masked) break;
	            var before = insert;
	            insert = (--insert < 0) ? 0 : insert;
	            if (before - insert)
	              process.stdout.write('\u001b[1D');
	            break;
	          case '\u001b[C': //right arrow
	            if (masked) break;
	            insert = (++insert > str.length) ? str.length : insert;
	            process.stdout.write('\u001b[' + (insert+ask.length+1) + 'G');
	            break;
	          default:
	            if (buf.toString()) {
	              str = str + buf.toString();
	              str = str.replace(/\0/g, '');
	              insert = str.length;
	              promptPrint(masked, ask, echo, str, insert);
	              process.stdout.write('\u001b[' + (insert+ask.length+1) + 'G');
	              buf = new Buffer(3);
	            }
	        }
	        continue; // any other 3 character sequence is ignored
	      }

	      // if it is not a control character seq, assume only one character is read
	      character = buf[read-1];

	      // catch a ^C and return null
	      if (character == 3){
	        process.stdout.write('^C\n');
	        fs.closeSync(fd);

	        if (sigint) process.exit(130);

	        process.stdin.setRawMode(wasRaw);

	        return null;
	      }

	      // catch the terminating character
	      if (character == term) {
	        fs.closeSync(fd);
	        if (!history) break;
	        if (!masked && str.length) history.push(str);
	        history.reset();
	        break;
	      }

	      // catch a TAB and implement autocomplete
	      if (character == 9) { // TAB
	        res = autocomplete(str);

	        if (str == res[0]) {
	          res = autocomplete('');
	        } else {
	          prevComplete = res.length;
	        }

	        if (res.length == 0) {
	          process.stdout.write('\t');
	          continue;
	        }

	        var item = res[cycle++] || res[cycle = 0, cycle++];

	        if (item) {
	          process.stdout.write('\r\u001b[K' + ask + item);
	          str = item;
	          insert = item.length;
	        }
	      }

	      if (character == 127 || (process.platform == 'win32' && character == 8)) { //backspace
	        if (!insert) continue;
	        str = str.slice(0, insert-1) + str.slice(insert);
	        insert--;
	        process.stdout.write('\u001b[2D');
	      } else {
	        if ((character < 32 ) || (character > 126))
	            continue;
	        str = str.slice(0, insert) + String.fromCharCode(character) + str.slice(insert);
	        insert++;
	      };

	      promptPrint(masked, ask, echo, str, insert);

	    }

	    process.stdout.write('\n')

	    process.stdin.setRawMode(wasRaw);

	    return str || value || '';
	  };


	  function promptPrint(masked, ask, echo, str, insert) {
	    if (masked) {
	        process.stdout.write('\u001b[2K\u001b[0G' + ask + Array(str.length+1).join(echo));
	    } else {
	      process.stdout.write('\u001b[s');
	      if (insert == str.length) {
	          process.stdout.write('\u001b[2K\u001b[0G'+ ask + str);
	      } else {
	        if (ask) {
	          process.stdout.write('\u001b[2K\u001b[0G'+ ask + str);
	        } else {
	          process.stdout.write('\u001b[2K\u001b[0G'+ str + '\u001b[' + (str.length - insert) + 'D');
	        }
	      }
	      process.stdout.write('\u001b[u');
	      process.stdout.write('\u001b[1C');
	    }
	  }
	};

	module.exports = create;


/***/ }
/******/ ]);